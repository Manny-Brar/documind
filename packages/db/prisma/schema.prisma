// Prisma Schema for DocuMind
// Based on PRD Technical Specification

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// ORGANIZATIONS
// ============================================================================

model Organization {
  id        String   @id @default(uuid()) @db.Uuid
  name      String   @db.VarChar(255)
  slug      String   @unique @db.VarChar(100)

  // Plan & Storage
  planId           String  @default("starter") @map("plan_id") @db.VarChar(50)
  storageQuotaBytes BigInt  @default(26843545600) @map("storage_quota_bytes") // 25 GB
  storageUsedBytes  BigInt  @default(0) @map("storage_used_bytes")

  // Vertex AI Search references
  vertexDataStoreId  String? @map("vertex_data_store_id") @db.VarChar(255)
  vertexSearchAppId  String? @map("vertex_search_app_id") @db.VarChar(255)

  // Settings (JSON for flexibility)
  settings Json @default("{}")

  // Billing (Stripe)
  stripeCustomerId     String? @map("stripe_customer_id") @db.VarChar(255)
  stripeSubscriptionId String? @map("stripe_subscription_id") @db.VarChar(255)
  subscriptionStatus   String? @map("subscription_status") @db.VarChar(50)
  currentPeriodEnd     DateTime? @map("current_period_end") @db.Timestamptz

  // Timestamps
  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime  @updatedAt @map("updated_at") @db.Timestamptz
  deletedAt DateTime? @map("deleted_at") @db.Timestamptz

  // Relations
  memberships     Membership[]
  documents       Document[]
  integrations    Integration[]
  apiKeys         ApiKey[]
  searchLogs      SearchLog[]
  auditLogs       AuditLog[]
  usageRecords    UsageRecord[]
  entities        Entity[]
  relationships   Relationship[]
  slackWorkspaces SlackWorkspace[]

  @@map("organizations")
}

// ============================================================================
// USERS
// ============================================================================

model User {
  id            String   @id @db.VarChar(255) // Better Auth generates non-UUID IDs
  email         String   @unique @db.VarChar(255)
  emailVerified Boolean  @default(false) @map("email_verified")

  // Profile (name and image required by Better Auth)
  name  String  @db.VarChar(255)
  image String? @db.VarChar(500) // Better Auth expects 'image'

  // MFA
  mfaEnabled       Boolean  @default(false) @map("mfa_enabled")
  mfaSecret        String?  @map("mfa_secret") @db.VarChar(255)
  mfaRecoveryCodes String[] @map("mfa_recovery_codes")

  // Security
  failedLoginAttempts Int       @default(0) @map("failed_login_attempts")
  lockedUntil         DateTime? @map("locked_until") @db.Timestamptz
  lastLoginAt         DateTime? @map("last_login_at") @db.Timestamptz
  lastLoginIp         String?   @map("last_login_ip") @db.VarChar(45)

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  memberships        Membership[]
  documents          Document[]
  sessions           Session[]
  accounts           Account[]
  searchLogs         SearchLog[]
  auditLogs          AuditLog[]
  invitedMembers     Membership[] @relation("InvitedBy")
  createdApiKeys     ApiKey[]     @relation("CreatedBy")
  revokedApiKeys     ApiKey[]     @relation("RevokedBy")
  slackUserMappings  SlackUserMapping[]

  @@map("users")
}

// ============================================================================
// MEMBERSHIPS (User-Org relationship)
// ============================================================================

model Membership {
  id     String @id @default(uuid()) @db.Uuid
  userId String @map("user_id") @db.VarChar(255) // References User with Better Auth ID
  orgId  String @map("org_id") @db.Uuid

  role   String @default("member") @db.VarChar(50) // admin, member, viewer
  status String @default("pending") @db.VarChar(50) // pending, active, suspended, removed

  // Invitation
  invitedById       String?   @map("invited_by") @db.VarChar(255) // References User
  invitationToken   String?   @map("invitation_token") @db.VarChar(255)
  invitationExpires DateTime? @map("invitation_expires") @db.Timestamptz

  // Timestamps
  joinedAt  DateTime? @map("joined_at") @db.Timestamptz
  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime  @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  user      User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  org       Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  invitedBy User?        @relation("InvitedBy", fields: [invitedById], references: [id])

  @@unique([userId, orgId])
  @@index([userId])
  @@index([orgId])
  @@index([invitationToken])
  @@map("memberships")
}

// ============================================================================
// SESSIONS (Better Auth compatible)
// ============================================================================

model Session {
  id        String   @id @db.VarChar(255) // Better Auth generates non-UUID IDs
  userId    String   @map("user_id") @db.VarChar(255) // References User with Better Auth ID

  // Better Auth required fields
  token     String   @unique @db.VarChar(255)
  expiresAt DateTime @map("expires_at") @db.Timestamptz
  ipAddress String?  @map("ip_address") @db.VarChar(45)
  userAgent String?  @map("user_agent") @db.Text

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@map("sessions")
}

// ============================================================================
// ACCOUNTS (Better Auth OAuth)
// ============================================================================

model Account {
  id        String @id @db.VarChar(255) // Better Auth generates non-UUID IDs
  userId    String @map("user_id") @db.VarChar(255) // References User with Better Auth ID

  // OAuth provider info
  accountId  String @map("account_id") @db.VarChar(255)
  providerId String @map("provider_id") @db.VarChar(50)

  // Tokens
  accessToken          String?   @map("access_token") @db.Text
  refreshToken         String?   @map("refresh_token") @db.Text
  accessTokenExpiresAt DateTime? @map("access_token_expires_at") @db.Timestamptz
  refreshTokenExpiresAt DateTime? @map("refresh_token_expires_at") @db.Timestamptz
  scope                String?   @db.Text
  idToken              String?   @map("id_token") @db.Text
  password             String?   @db.VarChar(255) // For email/password accounts

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([providerId, accountId])
  @@map("accounts")
}

// ============================================================================
// VERIFICATION (Better Auth email verification)
// ============================================================================

model Verification {
  id         String   @id @db.VarChar(255) // Better Auth generates non-UUID IDs
  identifier String   @db.VarChar(255)
  value      String   @db.Text
  expiresAt  DateTime @map("expires_at") @db.Timestamptz
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt  DateTime @updatedAt @map("updated_at") @db.Timestamptz

  @@index([identifier])
  @@map("verifications")
}

// ============================================================================
// DOCUMENT CHUNKS (for vector search)
// ============================================================================

model DocumentChunk {
  id         String @id @default(uuid()) @db.Uuid
  documentId String @map("document_id") @db.Uuid
  orgId      String @map("org_id") @db.Uuid

  // Chunk content
  content      String @db.Text
  chunkIndex   Int    @map("chunk_index")
  tokenCount   Int    @map("token_count")

  // Location in document
  pageNumber   Int?   @map("page_number")
  startOffset  Int?   @map("start_offset")
  endOffset    Int?   @map("end_offset")

  // Embedding stored as JSON array (can migrate to pgvector later)
  // For production, use: embedding Float[] or pgvector extension
  embedding    Json?  @default("[]")

  // Metadata
  metadata Json @default("{}")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  document Document        @relation(fields: [documentId], references: [id], onDelete: Cascade)
  mentions EntityMention[]

  @@unique([documentId, chunkIndex])
  @@index([orgId])
  @@index([documentId])
  @@map("document_chunks")
}

// ============================================================================
// DOCUMENTS
// ============================================================================

model Document {
  id           String @id @default(uuid()) @db.Uuid
  orgId        String @map("org_id") @db.Uuid
  uploadedById String? @map("uploaded_by") @db.VarChar(255) // References User

  // File info
  filename      String @db.VarChar(500)
  fileType      String @map("file_type") @db.VarChar(50)
  fileSizeBytes BigInt @map("file_size_bytes")
  mimeType      String? @map("mime_type") @db.VarChar(100)
  pageCount     Int?    @map("page_count")

  // Storage
  storageBucket String @map("storage_bucket") @db.VarChar(255)
  storagePath   String @map("storage_path") @db.VarChar(1000)

  // Source tracking
  source           String    @default("upload") @db.VarChar(50) // upload, google_drive, api
  sourceId         String?   @map("source_id") @db.VarChar(500)
  sourcePath       String?   @map("source_path") @db.VarChar(1000)
  sourceModifiedAt DateTime? @map("source_modified_at") @db.Timestamptz

  // Indexing
  indexStatus      String    @default("pending") @map("index_status") @db.VarChar(50)
  indexError       String?   @map("index_error")
  indexedAt        DateTime? @map("indexed_at") @db.Timestamptz
  vertexDocumentId String?   @map("vertex_document_id") @db.VarChar(255)

  // Metadata (flexible JSON)
  metadata Json @default("{}")

  // Timestamps
  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime  @updatedAt @map("updated_at") @db.Timestamptz
  deletedAt DateTime? @map("deleted_at") @db.Timestamptz

  // Relations
  org          Organization         @relation(fields: [orgId], references: [id], onDelete: Cascade)
  uploadedBy   User?                @relation(fields: [uploadedById], references: [id])
  chunks       DocumentChunk[]
  slackThreads SlackIndexedThread[] // Slack threads that were indexed into this document

  @@index([orgId])
  @@index([orgId, source, sourceId])
  @@index([indexStatus])
  @@map("documents")
}

// ============================================================================
// INTEGRATIONS
// ============================================================================

model Integration {
  id    String @id @default(uuid()) @db.Uuid
  orgId String @map("org_id") @db.Uuid

  type String  @db.VarChar(50) // google_drive, slack, dropbox
  name String? @db.VarChar(255)

  // Credentials (encrypted in application layer)
  credentials Json @default("{}")

  // Configuration
  settings Json @default("{}")

  // Sync status
  syncStatus   String    @default("pending") @map("sync_status") @db.VarChar(50)
  lastSyncAt   DateTime? @map("last_sync_at") @db.Timestamptz
  nextSyncAt   DateTime? @map("next_sync_at") @db.Timestamptz
  syncCursor   String?   @map("sync_cursor")
  errorMessage String?   @map("error_message")
  errorCount   Int       @default(0) @map("error_count")

  // Statistics
  documentsSynced Int    @default(0) @map("documents_synced")
  totalSizeBytes  BigInt @default(0) @map("total_size_bytes")

  // Timestamps
  createdAt      DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt      DateTime  @updatedAt @map("updated_at") @db.Timestamptz
  disconnectedAt DateTime? @map("disconnected_at") @db.Timestamptz

  // Relations
  org Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@index([orgId])
  @@index([nextSyncAt])
  @@map("integrations")
}

// ============================================================================
// SEARCH LOGS
// ============================================================================

model SearchLog {
  id     String  @id @default(uuid()) @db.Uuid
  orgId  String  @map("org_id") @db.Uuid
  userId String? @map("user_id") @db.VarChar(255) // References User

  // Query
  query     String @db.Text
  queryType String @default("search") @map("query_type") @db.VarChar(50) // search, question, followup

  // Results
  resultsCount    Int     @default(0) @map("results_count")
  answerGenerated Boolean @default(false) @map("answer_generated")

  // Performance
  latencyMs Int? @map("latency_ms")

  // Feedback
  feedback     String? @db.VarChar(50) // positive, negative
  feedbackText String? @map("feedback_text") @db.Text

  // Context
  sessionId String? @map("session_id") @db.VarChar(255)

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  org  Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user User?        @relation(fields: [userId], references: [id])

  @@index([orgId, createdAt(sort: Desc)])
  @@index([userId, createdAt(sort: Desc)])
  @@map("search_logs")
}

// ============================================================================
// AUDIT LOGS
// ============================================================================

model AuditLog {
  id     String  @id @default(uuid()) @db.Uuid
  orgId  String? @map("org_id") @db.Uuid
  userId String? @map("user_id") @db.VarChar(255) // References User

  // Event
  action       String  @db.VarChar(100) // e.g., auth.login, document.uploaded
  resourceType String  @map("resource_type") @db.VarChar(100)
  resourceId   String? @map("resource_id") @db.VarChar(255)

  // Context
  details   Json    @default("{}")
  ipAddress String? @map("ip_address") @db.VarChar(45)
  userAgent String? @map("user_agent") @db.Text
  requestId String? @map("request_id") @db.VarChar(255)

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  org  Organization? @relation(fields: [orgId], references: [id], onDelete: SetNull)
  user User?         @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([orgId, createdAt(sort: Desc)])
  @@index([userId, createdAt(sort: Desc)])
  @@index([resourceType, resourceId])
  @@index([action])
  @@map("audit_logs")
}

// ============================================================================
// API KEYS
// ============================================================================

model ApiKey {
  id        String  @id @default(uuid()) @db.Uuid
  orgId     String  @map("org_id") @db.Uuid
  createdById String? @map("created_by") @db.VarChar(255) // References User

  name      String @db.VarChar(255)
  keyHash   String @unique @map("key_hash") @db.VarChar(255)
  keyPrefix String @map("key_prefix") @db.VarChar(10) // e.g., "dm_live_abc"

  // Permissions
  scopes String[] @default(["read"])

  // Usage
  lastUsedAt DateTime? @map("last_used_at") @db.Timestamptz
  usageCount BigInt    @default(0) @map("usage_count")

  // Lifecycle
  expiresAt  DateTime? @map("expires_at") @db.Timestamptz
  revokedAt  DateTime? @map("revoked_at") @db.Timestamptz
  revokedById String?   @map("revoked_by") @db.VarChar(255) // References User

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  org       Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  createdBy User?        @relation("CreatedBy", fields: [createdById], references: [id])
  revokedBy User?        @relation("RevokedBy", fields: [revokedById], references: [id])

  @@index([orgId])
  @@map("api_keys")
}

// ============================================================================
// USAGE RECORDS
// ============================================================================

model UsageRecord {
  id    String @id @default(uuid()) @db.Uuid
  orgId String @map("org_id") @db.Uuid

  // Usage type: embedding, search, llm, storage
  usageType String @map("usage_type") @db.VarChar(50)

  // Quantity tracked
  quantity   Int    @default(0) // tokens, count, or bytes depending on type
  unitType   String @map("unit_type") @db.VarChar(50) // tokens, requests, bytes

  // Cost tracking (in cents/microdollars for precision)
  costMicros BigInt @default(0) @map("cost_micros") // cost in microdollars (1/1,000,000 dollar)

  // Context
  resourceType String? @map("resource_type") @db.VarChar(100) // document, search, etc.
  resourceId   String? @map("resource_id") @db.VarChar(255)
  metadata     Json    @default("{}")

  // Period (for aggregation)
  periodStart DateTime @map("period_start") @db.Date
  periodEnd   DateTime @map("period_end") @db.Date

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  org Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@index([orgId, periodStart])
  @@index([orgId, usageType, periodStart])
  @@map("usage_records")
}

// ============================================================================
// KNOWLEDGE GRAPH: ENTITIES
// ============================================================================

// Entity types for classification
// PERSON, ORGANIZATION, LOCATION, DATE, CONCEPT, PRODUCT, EVENT, TOPIC
enum EntityType {
  // Core entity types
  PERSON
  ORGANIZATION
  LOCATION
  DATE
  CONCEPT
  PRODUCT
  EVENT
  TOPIC
  MONEY
  TECHNOLOGY
  OTHER

  // Slack-specific entity types (for Slack message indexing)
  SLACK_WORKSPACE   // The Slack workspace/team
  SLACK_USER        // Individual Slack user (links to PERSON)
  SLACK_CHANNEL     // Slack channel (public, private, DM)
  SLACK_THREAD      // Conversation thread
  SLACK_MESSAGE     // Individual message
  SLACK_BOT         // Bot account (distinct from human users)
  SLACK_FILE        // File shared in Slack
  SLACK_REACTION    // Emoji reaction on a message
}

model Entity {
  id    String @id @default(uuid()) @db.Uuid
  orgId String @map("org_id") @db.Uuid

  // Entity identification
  name           String     @db.VarChar(500)           // Canonical/normalized name
  type           EntityType @default(OTHER)
  normalizedName String     @map("normalized_name") @db.VarChar(500) // Lowercased for matching

  // Aliases for entity resolution (e.g., "John Smith", "J. Smith", "John")
  aliases String[] @default([])

  // Embedding for semantic entity matching/deduplication
  embedding Json? @default("[]")

  // Metadata (additional structured info about the entity)
  metadata Json @default("{}")

  // Extraction confidence (0-1, average across mentions)
  confidence Float @default(0.5)

  // Counts for quick access
  mentionCount   Int @default(0) @map("mention_count")
  documentCount  Int @default(0) @map("document_count")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  org                   Organization      @relation(fields: [orgId], references: [id], onDelete: Cascade)
  mentions              EntityMention[]
  relationshipsAsSource Relationship[]    @relation("SourceEntity")
  relationshipsAsTarget Relationship[]    @relation("TargetEntity")

  @@unique([orgId, normalizedName, type])
  @@index([orgId])
  @@index([orgId, type])
  @@index([normalizedName])
  @@index([orgId, mentionCount(sort: Desc)])
  @@map("entities")
}

// ============================================================================
// KNOWLEDGE GRAPH: ENTITY MENTIONS
// ============================================================================

model EntityMention {
  id       String @id @default(uuid()) @db.Uuid
  entityId String @map("entity_id") @db.Uuid
  chunkId  String @map("chunk_id") @db.Uuid
  orgId    String @map("org_id") @db.Uuid

  // Mention details
  mentionText   String @map("mention_text") @db.VarChar(500)  // Actual text in document
  contextBefore String @default("") @map("context_before") @db.VarChar(200) // Text before mention
  contextAfter  String @default("") @map("context_after") @db.VarChar(200)  // Text after mention

  // Position in chunk
  startOffset Int @map("start_offset")
  endOffset   Int @map("end_offset")

  // Extraction confidence (0-1)
  confidence Float @default(0.5)

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  entity Entity        @relation(fields: [entityId], references: [id], onDelete: Cascade)
  chunk  DocumentChunk @relation(fields: [chunkId], references: [id], onDelete: Cascade)

  @@index([entityId])
  @@index([chunkId])
  @@index([orgId])
  @@map("entity_mentions")
}

// ============================================================================
// KNOWLEDGE GRAPH: RELATIONSHIPS
// ============================================================================

// Relationship types between entities
enum RelationshipType {
  // Person relationships
  WORKS_FOR       // Person -> Organization
  REPORTS_TO      // Person -> Person
  COLLABORATES    // Person <-> Person
  AUTHORED        // Person -> Document/Content
  MENTIONED       // Person/Org -> Topic/Concept

  // Organization relationships
  SUBSIDIARY_OF   // Organization -> Organization
  PARTNER_OF      // Organization <-> Organization
  COMPETES_WITH   // Organization <-> Organization

  // Topic/Concept relationships
  DISCUSSES       // Any -> Topic
  RELATES_TO      // Generic relationship
  LOCATED_IN      // Any -> Location
  OCCURRED_ON     // Event -> Date
  INVOLVES        // Event -> Person/Organization

  // Generic
  ASSOCIATED      // Generic association
  OTHER           // Fallback

  // Slack-specific structural relationships
  MEMBER_OF       // SLACK_USER -> SLACK_WORKSPACE
  CONTAINS        // SLACK_CHANNEL -> SLACK_MESSAGE, SLACK_THREAD -> SLACK_MESSAGE
  PART_OF         // SLACK_MESSAGE -> SLACK_THREAD

  // Slack-specific communication relationships
  AUTHORED_BY     // SLACK_MESSAGE -> SLACK_USER (attribution)
  POSTED_IN       // SLACK_USER -> SLACK_CHANNEL (activity)
  REPLIED_TO      // SLACK_MESSAGE -> SLACK_MESSAGE (thread flow)
  MENTIONED_IN    // SLACK_USER -> SLACK_MESSAGE (who was @mentioned)

  // Slack-specific collaborative relationships
  COLLABORATED_IN // SLACK_USER <-> SLACK_USER (co-participation in threads)
  ACTIVE_IN       // SLACK_USER -> SLACK_THREAD (thread participation)

  // Slack-specific semantic relationships
  REFERENCES      // SLACK_MESSAGE -> SLACK_FILE
  SHARES          // SLACK_USER -> SLACK_FILE

  // Slack-specific signal relationships (for RAG confidence)
  REACTED_WITH    // SLACK_USER -> SLACK_MESSAGE (individual reaction)
  REACTED_TO      // SLACK_REACTION -> SLACK_MESSAGE (aggregated)
  PINNED_IN       // SLACK_MESSAGE -> SLACK_CHANNEL (importance signal)
}

model Relationship {
  id       String @id @default(uuid()) @db.Uuid
  orgId    String @map("org_id") @db.Uuid

  // Entities involved
  sourceEntityId String @map("source_entity_id") @db.Uuid
  targetEntityId String @map("target_entity_id") @db.Uuid

  // Relationship classification
  type        RelationshipType @default(RELATES_TO)
  description String?          @db.VarChar(500) // Natural language description

  // Weight/strength of relationship (0-1)
  weight Float @default(0.5)

  // Confidence of extraction (0-1)
  confidence Float @default(0.5)

  // Evidence: which chunks support this relationship
  evidenceChunkIds String[] @default([]) @map("evidence_chunk_ids")

  // Metadata (additional context, timestamps, etc.)
  metadata Json @default("{}")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  org          Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  sourceEntity Entity       @relation("SourceEntity", fields: [sourceEntityId], references: [id], onDelete: Cascade)
  targetEntity Entity       @relation("TargetEntity", fields: [targetEntityId], references: [id], onDelete: Cascade)

  @@unique([orgId, sourceEntityId, targetEntityId, type])
  @@index([orgId])
  @@index([sourceEntityId])
  @@index([targetEntityId])
  @@index([type])
  @@map("relationships")
}

// ============================================================================
// SLACK INTEGRATION
// ============================================================================

model SlackWorkspace {
  id          String   @id @default(uuid()) @db.Uuid
  orgId       String   @map("org_id") @db.Uuid
  teamId      String   @unique @map("team_id") @db.VarChar(20)   // Slack team ID (T12345...)
  teamName    String   @map("team_name") @db.VarChar(255)
  botUserId   String   @map("bot_user_id") @db.VarChar(20)       // Bot user ID (U12345...)

  // OAuth tokens (encrypted at application layer)
  accessToken String   @map("access_token") @db.Text

  // Scopes granted during OAuth
  scopes      String[] @default([])

  // Installation tracking
  installerId String?  @map("installer_id") @db.VarChar(20)      // Slack user who installed

  // Status
  isActive    Boolean  @default(true) @map("is_active")

  // Timestamps
  installedAt DateTime @default(now()) @map("installed_at") @db.Timestamptz
  updatedAt   DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  org          Organization         @relation(fields: [orgId], references: [id], onDelete: Cascade)
  userMappings SlackUserMapping[]
  channels     SlackChannelConfig[] // Channels configured for indexing

  @@index([orgId])
  @@map("slack_workspaces")
}

model SlackUserMapping {
  id               String  @id @default(uuid()) @db.Uuid
  slackWorkspaceId String  @map("slack_workspace_id") @db.Uuid
  slackUserId      String  @map("slack_user_id") @db.VarChar(20)  // Slack user ID (U12345...)
  userId           String? @map("user_id") @db.VarChar(255)       // DocuMind user if linked

  // Cached Slack user info
  slackUsername    String? @map("slack_username") @db.VarChar(255)
  slackDisplayName String? @map("slack_display_name") @db.VarChar(255)
  slackEmail       String? @map("slack_email") @db.VarChar(255)

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  workspace SlackWorkspace @relation(fields: [slackWorkspaceId], references: [id], onDelete: Cascade)
  user      User?          @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@unique([slackWorkspaceId, slackUserId])
  @@index([slackWorkspaceId])
  @@index([userId])
  @@index([slackEmail])
  @@map("slack_user_mappings")
}

// Channel configuration for message indexing
model SlackChannelConfig {
  id               String  @id @default(uuid()) @db.Uuid
  slackWorkspaceId String  @map("slack_workspace_id") @db.Uuid
  channelId        String  @map("channel_id") @db.VarChar(20)    // Slack channel ID (C12345...)
  channelName      String  @map("channel_name") @db.VarChar(255)

  // Channel type
  channelType      String  @default("public") @map("channel_type") @db.VarChar(20) // public, private, group_dm

  // Indexing configuration
  isEnabled        Boolean @default(true) @map("is_enabled")      // Whether to index this channel
  indexRepliesOnly Boolean @default(true) @map("index_replies_only") // Only index threaded replies
  minThreadLength  Int     @default(2) @map("min_thread_length")  // Min messages to index a thread

  // Sync state
  lastSyncAt       DateTime? @map("last_sync_at") @db.Timestamptz
  lastMessageTs    String?   @map("last_message_ts") @db.VarChar(30) // Slack message timestamp

  // Channel metadata
  memberCount      Int?      @map("member_count")
  topic            String?   @db.VarChar(500)
  purpose          String?   @db.VarChar(500)

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  workspace      SlackWorkspace       @relation(fields: [slackWorkspaceId], references: [id], onDelete: Cascade)
  indexedThreads SlackIndexedThread[]

  @@unique([slackWorkspaceId, channelId])
  @@index([slackWorkspaceId])
  @@index([slackWorkspaceId, isEnabled])
  @@map("slack_channel_configs")
}

// Indexed Slack threads (for deduplication and tracking)
model SlackIndexedThread {
  id               String  @id @default(uuid()) @db.Uuid
  channelConfigId  String  @map("channel_config_id") @db.Uuid
  threadTs         String  @map("thread_ts") @db.VarChar(30)       // Slack thread timestamp

  // Thread metadata
  parentMessageTs  String  @map("parent_message_ts") @db.VarChar(30) // Parent message timestamp
  messageCount     Int     @default(0) @map("message_count")
  participantCount Int     @default(0) @map("participant_count")

  // Generated title (from first message or AI-generated)
  title            String? @db.VarChar(500)

  // Link to DocuMind document (when thread is indexed)
  documentId       String? @map("document_id") @db.Uuid

  // Processing state
  status           String  @default("pending") @db.VarChar(20)     // pending, processing, indexed, failed
  lastProcessedAt  DateTime? @map("last_processed_at") @db.Timestamptz
  errorMessage     String? @map("error_message") @db.Text

  // Thread metadata for graph
  topicSummary     String? @map("topic_summary") @db.Text          // AI-generated topic summary
  participants     String[] @default([])                           // Array of Slack user IDs

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  channelConfig SlackChannelConfig @relation(fields: [channelConfigId], references: [id], onDelete: Cascade)
  document      Document?          @relation(fields: [documentId], references: [id], onDelete: SetNull)

  @@unique([channelConfigId, threadTs])
  @@index([channelConfigId])
  @@index([documentId])
  @@index([status])
  @@map("slack_indexed_threads")
}
